#!/bin/bash

set -euo pipefail

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

export ROOT_DIR=$(dirname $0)
source $ROOT_DIR/common.sh
source $ROOT_DIR/installers/testcontainers.sh
source $ROOT_DIR/installers/sdkman.sh
source $ROOT_DIR/installers/java.sh
source $ROOT_DIR/installers/gradle.sh
source $ROOT_DIR/installers/maven.sh
source $ROOT_DIR/installers/node.sh
source $ROOT_DIR/installers/python.sh

dest=$1

payload="$(cat <&0)"

# Compute hash for current payload
hash=$(compute_hash "$payload")

# Extract properties from source payload
extra_dependencies=$(jq -r '(.source.dependencies // [] | join(" "))' <<< "$payload")
repository=$(jq -r '(.source.repository // "")' <<< "$payload")
username=$(jq -r '(.source.username // "")' <<< "$payload")
password=$(jq -r '(.source.password // "")' <<< "$payload")
hook=$(jq -r '(.source.hook // "")' <<< "$payload")
verbose=$(jq -r '(.source.verbose // "")' <<< "$payload")
export VERBOSE=$verbose

if [[ -n "$extra_dependencies" ]]; then
  info "dependencies=$extra_dependencies"
fi

# Get apt dependencies for all installation options and deduplicate
dependencies="
  $(sdkman_get_dependencies "$payload")
  $(node_get_dependencies "$payload")
  $(python_get_dependencies "$payload")
  $(testcontainers_get_dependencies "$payload")
"
dependencies=$(echo "$dependencies" | tr -s ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ $//')

if [[ -n "$repository" && -n "$username" && -n "$password" ]]; then
  log_on_error buildah login -u "$username" -p "$password" "$repository"
fi

ctr=$(buildah from "debian:stable-slim")

if [ ! -z "$dependencies" ]; then
  info "installing required dependencies..."
  log_on_error buildah run "$ctr" -- bash -lc "apt-get update && apt-get install -y $dependencies && apt autoremove -y && apt clean -y"
  info "dependencies installed..."
fi

set_env "$ctr" "BASH_ENV=/root/.bashrc"
set_env "$ctr" "ENV=/root/.bashrc"

log_on_error buildah run "$ctr" -- bash -lc "useradd -m $RUNTIME_USER -u 1000"

log_on_error buildah run "$ctr" -- sh -lc "
  echo \"$RUNTIME_USER:100000:65536\" >> /etc/subuid &&
  echo \"$RUNTIME_USER:100000:65536\" >> /etc/subgid"

info "installing candidates"

# Common setup stuff
log_on_error buildah run "$ctr" -- bash -lc "touch /root/.bashrc && mkdir -p $RUNTIME_DIR"

sdkman_install "$ctr" "$payload"
java_install "$ctr" "$payload"
gradle_install "$ctr" "$payload"
maven_install "$ctr" "$payload"
node_install "$ctr" "$payload"
python_install "$ctr" "$payload"
testcontainers_install "$ctr" "$payload"

node_cleanup "$ctr" "$payload"
python_cleanup "$ctr" "$payload"
sdkman_cleanup "$ctr" "$payload"

# Delete any .git folders which e.g. nvm use.
log_on_error buildah run "$ctr" -- bash -lc 'find /root -maxdepth 3 -type d -name ".git" ! -path "./.git" -exec rm -rf {} +'

if [ ! -z "$extra_dependencies" ]; then
  info "installing extra_dependencies..."
  log_on_error buildah run "$ctr" -- bash -lc "apt-get update && apt-get install -y $extra_dependencies"
  info "extra_dependencies installed"
fi

if [[ -n "$hook" ]]; then
  info "running custom hook"
  log_on_error buildah run "$ctr" -- bash -lc "$hook"
  info "hook finished"
fi

info "cleaning final image..."
log_on_error buildah run "$ctr" -- bash -lc "apt autoremove -y && apt clean -y"
info "cleaning completed"

# By squashing the image we have only one layer containing the rootfs
log_on_error buildah commit --squash -D --rm "$ctr" "setup-runtime-image"
log_on_error buildah push setup-runtime-image oci:/tmp/setup-runtime-out

# Define env vars to load the bash profile in non interactive shells
# Add cache environment variables so caching is straightforward
jq -n "{
  env: [$(sed 's/.*/"&"/' /tmp/env_vars | tr '\n' ',' | sed 's/,$//')],
  user: \"\"
}" > "$dest/metadata.json"

log_on_error cat $dest/metadata.json

mkdir -p $dest/rootfs
# Get the blob with the largest file size. Not clean but it is fast and is almost always correct.
rootfs=$(find /tmp/setup-runtime-out/blobs/sha256 -type f -printf "%s %p\n" | sort -nr | head -n 1 | cut -d' ' -f2-)

# Unpack the rootfs to the output directory.
tar -xf "$rootfs" -C "$dest/rootfs"

info "Total size of image: $(ls -lh "$rootfs" | awk '{print $5}')"

jq -n --arg hash "$hash" '{ "version": { "hash": $hash }, "metadata": [] }' >&3
