#!/bin/bash

set -eo pipefail

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

export ROOT_DIR=$(dirname $0)
source $ROOT_DIR/common.sh
source $ROOT_DIR/installers/testcontainers.sh
source $ROOT_DIR/installers/sdkman.sh
source $ROOT_DIR/installers/node.sh
source $ROOT_DIR/installers/pyenv.sh
source $ROOT_DIR/installers/golang.sh

dest=$1

payload="$(cat <&0)"

hash=$(compute_hash "$payload")

extra_dependencies=$(jq -r '(.source.dependencies // [] | join(" "))' <<< "$payload")
hook=$(jq -r '(.source.hook // "")' <<< "$payload")
verbose=$(jq -r '(.source.verbose // "")' <<< "$payload")
telemetry=$(jq -r '(.source.telemetry.disable // "")' <<< "$payload")

export testcontainers_enabled=$(jq -r '(.source.testcontainers.enabled // "false")' <<< "$payload")
export java_version=$(jq -r '(.source.java.version // "")' <<< "$payload")
export sdkman_enabled=$(jq -r '(.source.sdkman.enabled // "false")' <<< "$payload")
export extra_java_versions=$(jq -r '(.source.java.extra_versions // [])' <<< "$payload")
export nvm_enabled=$(jq -r '(.source.nvm.enabled // "false")' <<< "$payload")
export nodejs_version=$(jq -r '(.source.nodejs.version // "")' <<< "$payload")
export yarn_version=$(jq -r '(.source.nodejs.yarn.version // "")' <<< "$payload")
export pnpm_version=$(jq -r '(.source.nodejs.pnpm.version // "")' <<< "$payload")

export maven_version=$(jq -r '(.source.maven.version // "")' <<< "$payload")
export maven_wrapper=$(jq -r '(.source.maven.wrapper // "false")' <<< "$payload")
export gradle_version=$(jq -r '(.source.gradle.version // "")' <<< "$payload")
export gradle_wrapper=$(jq -r '(.source.gradle.wrapper // "false")' <<< "$payload")

export pyenv_enabled=$(jq -r '(.source.pyenv.enabled // "false")' <<< "$payload")
export golang_version=$(jq -r '(.source.golang.version // "")' <<< "$payload")
export debian_proxy=$(jq -r '(.source.debian_proxy // "")' <<< "$payload")

export VERBOSE=$verbose
export DISABLE_TELEMETRY=$telemetry
export DEBUG=$(jq -r '(.source.debug // "false")' <<< "$payload")

dependencies="
  $extra_dependencies
  $(sdkman_get_dependencies)
  $(node_get_dependencies)
  $(pyenv_get_dependencies)
  $(golang_get_dependencies)
  $(testcontainers_get_dependencies)
"
dependencies=$(echo "$dependencies" | tr -s ' ' '\n' | sort -u | tr '\n' ' ' | xargs)

info "Bootstrapping Debian rootfs with mmdebstrap (this can take some time)..."

WORK_ROOTFS="/tmp/work-rootfs.tar"

DEBIAN_VERSION=trixie
if [[ "$testcontainers_enabled" = "true" ]]; then
  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
  chmod a+r /etc/apt/keyrings/docker.asc

  # Add the repository to Apt sources:
  tee /etc/apt/sources.list.d/docker.sources <<EOF
Types: deb
URIs: https://download.docker.com/linux/debian
Suites: $DEBIAN_VERSION
Components: stable
Signed-By: /etc/apt/keyrings/docker.asc
EOF
fi

args=()

if [[ -n "${dependencies:-}" ]]; then
  args+=( "--include=$dependencies" )
fi

export OUTPUT_FILE=/tmp/info_log
touch $OUTPUT_FILE
tail -f "$OUTPUT_FILE" &
INFO_LOGGER_PID=$!

if [[ -n "${debian_proxy:-}" ]]; then
  info "Using debian proxy: $debian_proxy"
  args+=( "--aptopt=Acquire::http { Proxy \"$debian_proxy\"; }" )
fi

args+=(
  --variant=essential \
  --mode=auto \
  --aptopt='Acquire::Languages "none"' \
  --aptopt='Apt::Install-Recommends "false"' \
  --aptopt='APT::Get::Install-Suggests "false"' \
  --dpkgopt='path-exclude=/usr/share/man/*' \
  --dpkgopt='path-include=/usr/share/man/man[1-9]/*' \
  --dpkgopt='path-exclude=/usr/share/locale/*' \
  --dpkgopt='path-include=/usr/share/locale/locale.alias' \
  --dpkgopt='path-exclude=/usr/share/doc/*' \
  --dpkgopt='path-include=/usr/share/doc/*/copyright' \
  --dpkgopt='path-include=/usr/share/doc/*/changelog.Debian.*' \
  --skip=output/dev \
  --hook-dir="$ROOT_DIR/hooks" \
  "$DEBIAN_VERSION" "$WORK_ROOTFS"
)

log_on_error mmdebstrap "${args[@]}"

kill $INFO_LOGGER_PID

mkdir -p "$dest/rootfs/"
tar --delete -f $WORK_ROOTFS ./var/cache/apt ./var/lib/apt/lists ./tmp
tar -xf "$WORK_ROOTFS" -C "$dest/rootfs/"
rm $WORK_ROOTFS
mkdir -p "$dest/rootfs$RUNTIME_DIR"

if [[ -n "$hook" ]]; then
  log_on_error chroot_exec "$dest/rootfs/" "set -e;$hook"
fi

set_env "BASH_ENV=/root/.bashrc"
set_env "ENV=/root/.bashrc"

# Define env vars to load the bash profile in non interactive shells
# Add cache environment variables so caching is straightforward
jq -n "{
  env: [$(sed 's/.*/\"&\"/' /tmp/env_vars | tr '\n' ',' | sed 's/,$//')],
  user: \"\"}
" > "$dest/metadata.json"

log_on_error cat "$dest/metadata.json"

if [[ "$testcontainers_enabled" = "true" ]]; then
  # Copy docker includes into the rootfs.
  cp -r "$ROOT_DIR/includes/docker" "$dest/rootfs$RUNTIME_DIR"

  add_trap teardown_docker EXIT
fi

add_trap prepare_cache EXIT
add_trap 'if [[ "$DEBUG" = "true" ]]; then info "Cache size in $CACHE_DIR:"; info "$(du -sh "$CACHE_DIR" 2>/dev/null)" || true; fi' EXIT

for f in /tmp/traps_*; do
  if [[ -e "$f" ]]; then
    sig="${f#/tmp/traps_}"
    cmds=$(paste -sd ";" "$f")
    echo "function trap_$sig() {
  $cmds
}" >> "$dest/rootfs/root/.bashrc"
    echo "trap \"trap_$sig\" $sig" >> "$dest/rootfs/root/.bashrc"
  fi
done

cat "$ROOT_DIR/includes/bashrc.sh" >> "$dest/rootfs/root/.bashrc"

info "Total size of setup-runtime rootfs: $(du -sh "$dest/rootfs" | awk '{print $1}')"

touch /tmp/metadata || true

METADATA=$(cat /tmp/metadata 2>/dev/null | tr -s '\n' ',' | sed 's/,$//')

# Cleanup of nodejs if any.
rm -rf /tmp/node-compile-cache

jq -n \
  --arg hash "$hash" \
  "{ version: { hash: \$hash }, metadata: [$METADATA] }" >&3
