#!/bin/bash

set -euo pipefail

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

export ROOT_DIR=$(dirname $0)
source $ROOT_DIR/common.sh
source $ROOT_DIR/installers/testcontainers.sh
source $ROOT_DIR/installers/sdkman.sh
source $ROOT_DIR/installers/java.sh
source $ROOT_DIR/installers/gradle.sh
source $ROOT_DIR/installers/maven.sh
source $ROOT_DIR/installers/node.sh
source $ROOT_DIR/installers/python.sh

dest=$1

payload="$(cat <&0)"

# Compute hash for current payload
hash=$(compute_hash "$payload")

# Extract properties from source payload
extra_dependencies=$(jq -r '(.source.dependencies // [] | join(" "))' <<< "$payload")
repository=$(jq -r '(.source.repository // "")' <<< "$payload")
username=$(jq -r '(.source.username // "")' <<< "$payload")
password=$(jq -r '(.source.password // "")' <<< "$payload")
hook=$(jq -r '(.source.hook // "")' <<< "$payload")
verbose=$(jq -r '(.source.verbose // "")' <<< "$payload")
telemetry=$(jq -r '(.source.telemetry.disable // "")' <<< "$payload")
security_mode=$(jq -r '(.source.security.mode // "recommended")' <<< "$payload")
fail_on_severity=$(jq -r '(.source.security.fail_on_severity // "")' <<< "$payload")
export VERBOSE=$verbose
export DISABLE_TELEMETRY=$telemetry

if [[ -n "$extra_dependencies" ]]; then
  info "dependencies=$extra_dependencies"
fi

# Get apt dependencies for all installation options and deduplicate
build_dependencies="
  $(sdkman_get_dependencies "$payload")
  $(node_get_dependencies "$payload")
  $(python_get_dependencies "$payload")
  $(testcontainers_get_dependencies "$payload")
"
build_dependencies=$(echo "$build_dependencies" | tr -s ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ $//')

if [[ -n "$repository" && -n "$username" && -n "$password" ]]; then
  log_on_error buildah login -u "$username" -p "$password" "$repository"
fi

ctr=$(buildah from "debian:stable-slim")

if [ ! -z "$build_dependencies" ]; then
  info "installing required dependencies..."
  log_on_error buildah run "$ctr" -- bash -lc "apt-get update &&
    apt-get upgrade &&
    apt-get install -y --no-install-recommends $build_dependencies && apt autoremove -y && apt clean -y
  "
  info "dependencies installed..."
fi

set_env "$ctr" "BASH_ENV=/root/.bashrc"
set_env "$ctr" "ENV=/root/.bashrc"

info "installing candidates"

# Common setup stuff
log_on_error buildah run "$ctr" -- bash -lc "touch /root/.bashrc && mkdir -p $RUNTIME_DIR"

sdkman_install "$ctr" "$payload"
java_install "$ctr" "$payload"
gradle_install "$ctr" "$payload"
maven_install "$ctr" "$payload"
node_install "$ctr" "$payload"
python_install "$ctr" "$payload"
testcontainers_install "$ctr" "$payload"

node_cleanup "$ctr" "$payload"
python_cleanup "$ctr" "$payload"
sdkman_cleanup "$ctr" "$payload"

# Delete any .git folders which e.g. nvm use.
log_on_error buildah run "$ctr" -- bash -lc 'find /root -maxdepth 3 -type d -name ".git" ! -path "./.git" -exec rm -rf {} +'

# Remove dependencies that we needed for e.g. compilation.
log_on_error buildah run "$ctr" -- bash -lc "apt-get purge -y $build_dependencies && apt-get install -y --no-install-recommends ca-certificates"

if [ ! -z "$extra_dependencies" ]; then
  info "installing dependencies..."
  log_on_error buildah run "$ctr" -- bash -lc "apt-get update && apt-get install -y --no-install-recommends $extra_dependencies"
  info "dependencies installed"
fi

if [[ -n "$hook" ]]; then
  info "running custom hook"
  log_on_error buildah run "$ctr" -- bash -lc "set -e;$hook"
  info "hook finished"
fi

info "cleaning final image..."
log_on_error buildah run "$ctr" -- bash -lc "apt autoremove -y && apt clean -y"
info "cleaning completed"

# Do this at the last step since this will change bashrc to start the docker daemon.
finalize_testcontainers "$ctr"

# By squashing the image we have only one layer containing the rootfs
log_on_error buildah commit --squash -D --rm "$ctr" "setup-runtime-image"
log_on_error buildah push setup-runtime-image oci:/tmp/setup-runtime-out

# Define env vars to load the bash profile in non interactive shells
# Add cache environment variables so caching is straightforward
jq -n "{
  env: [$(sed 's/.*/"&"/' /tmp/env_vars | tr '\n' ',' | sed 's/,$//')],
  user: \"\"
}" > "$dest/metadata.json"

log_on_error cat $dest/metadata.json

mkdir -p $dest/rootfs
# Get the blob with the largest file size. Not clean but it is fast and is almost always correct.
rootfs=$(find /tmp/setup-runtime-out/blobs/sha256 -type f -printf "%s %p\n" | sort -nr | head -n 1 | cut -d' ' -f2-)

# Unpack the rootfs to the output directory.
tar -xf "$rootfs" -C "$dest/rootfs"

if [ "$security_mode" = "strictest" ] || [ "$security_mode" = "strict" ] || [ "$security_mode" = "recommended" ]; then
  _fail_on_severity="critical"
  if [ "$security_mode" = "strictest" ]; then
    _fail_on_severity="high"
  fi
  if [[ -n "$extra_dependencies" ]]; then
    _fail_on_severity="$fail_on_severity"
  fi
  info "Scanning container rootfs for security vulnerabilities (fail on severity: $_fail_on_severity)"

  grype db update
  grype "dir:$dest/rootfs" --fail-on $_fail_on_severity
fi

info "Total size of setup-runtime rootfs: $(ls -lh "$rootfs" | awk '{print $5}')"

touch /tmp/metadata

METADATA=$(cat /tmp/metadata | tr -s '\n' ',' | sed 's/,$//')

jq -n \
  --arg hash "$hash" \
  "{ version: { hash: \$hash }, metadata: [$METADATA] }" >&3
