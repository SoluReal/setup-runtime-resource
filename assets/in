#!/bin/bash

set -euo pipefail

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

export ROOT_DIR=$(dirname $0)
source $ROOT_DIR/common.sh
source $ROOT_DIR/installers/testcontainers.sh
source $ROOT_DIR/installers/sdkman.sh
source $ROOT_DIR/installers/java.sh
source $ROOT_DIR/installers/gradle.sh
source $ROOT_DIR/installers/maven.sh
source $ROOT_DIR/installers/node.sh
source $ROOT_DIR/installers/python.sh

trap 'umount_chroot "$WORK_ROOTFS" || true' EXIT

dest=$1

payload="$(cat <&0)"

# Compute hash for current payload
hash=$(compute_hash "$payload")

# Extract properties from source payload
extra_dependencies=$(jq -r '(.source.dependencies // [] | join(" "))' <<< "$payload")
hook=$(jq -r '(.source.hook // "")' <<< "$payload")
verbose=$(jq -r '(.source.verbose // "")' <<< "$payload")
telemetry=$(jq -r '(.source.telemetry.disable // "")' <<< "$payload")
security_mode=$(jq -r '(.source.security.mode // "default")' <<< "$payload")
fail_on_severity=$(jq -r '(.source.security.fail_on_severity // "")' <<< "$payload")
grype_config=$(jq -r '(.source.security.grype_config // "")' <<< "$payload")
export VERBOSE=$verbose
export DISABLE_TELEMETRY=$telemetry

# Get apt dependencies for all installation options and deduplicate
build_dependencies="
  $(sdkman_get_dependencies "$payload")
  $(node_get_dependencies "$payload")
  $(python_get_dependencies "$payload")
  $(testcontainers_get_dependencies "$payload")
"
build_dependencies=$(echo "$build_dependencies" | tr -s ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/ $//')

# Bootstrap a Debian rootfs using mmdebstrap
info "Bootstrapping Debian rootfs with mmdebstrap..."
rm -rf "$WORK_ROOTFS"
mkdir -p "$WORK_ROOTFS"
# Include minimal tools; we'll apt-get others as needed
log_on_error mmdebstrap --variant=minbase \
  --include="bash ca-certificates curl gnupg jq" \
  stable "$WORK_ROOTFS" "http://deb.debian.org/debian"

mount_chroot "$WORK_ROOTFS"

# Ensure base dirs and bashrc
log_on_error chroot_exec "$WORK_ROOTFS" "touch /root/.bashrc && mkdir -p $RUNTIME_DIR"

# Install build-time deps if any
if [ -n "$build_dependencies" ]; then
  info "installing required dependencies..."
  log_on_error chroot_exec "$WORK_ROOTFS" "apt-get update && apt-get upgrade -y && apt-get install -y --no-install-recommends $build_dependencies && apt autoremove -y && apt clean -y"
  info "dependencies installed..."
fi

set_env "$WORK_ROOTFS" "BASH_ENV=/root/.bashrc"
set_env "$WORK_ROOTFS" "ENV=/root/.bashrc"

info "installing candidates"

sdkman_install "$WORK_ROOTFS" "$payload"
java_install "$WORK_ROOTFS" "$payload"
gradle_install "$WORK_ROOTFS" "$payload"
maven_install "$WORK_ROOTFS" "$payload"
node_install "$WORK_ROOTFS" "$payload"
python_install "$WORK_ROOTFS" "$payload"
testcontainers_install "$WORK_ROOTFS" "$payload"

node_cleanup "$WORK_ROOTFS" "$payload"
python_cleanup "$WORK_ROOTFS" "$payload"
sdkman_cleanup "$WORK_ROOTFS" "$payload"

# Delete any .git folders which e.g. nvm use.
log_on_error chroot_exec "$WORK_ROOTFS" "find /root -maxdepth 3 -type d -name '.git' ! -path './.git' -exec rm -rf {} +"

# Remove build-time dependencies and keep ca-certificates
if [ -n "$build_dependencies" ]; then
  log_on_error chroot_exec "$WORK_ROOTFS" "apt-get purge -y $build_dependencies || true && apt-get update && apt-get install -y --no-install-recommends ca-certificates"
fi

# Extra runtime dependencies
if [ -n "$extra_dependencies" ]; then
  info "installing dependencies..."
  log_on_error chroot_exec "$WORK_ROOTFS" "apt-get update && apt-get install -y --no-install-recommends $extra_dependencies"
  info "dependencies installed"
fi

# Custom hook
if [ -n "$hook" ]; then
  info "running custom hook"
  log_on_error chroot_exec "$WORK_ROOTFS" "set -e; $hook"
  info "hook finished"
fi

info "cleaning final image..."
log_on_error chroot_exec "$WORK_ROOTFS" "apt autoremove -y && apt clean -y"
info "cleaning completed"

# Do this at the last step since this will change bashrc to start the docker daemon.
finalize_testcontainers "$WORK_ROOTFS" "$payload"

_fail_on_severity="critical"
if [ "$security_mode" = "strictest" ]; then
  _fail_on_severity="high"
fi
if [ -n "$fail_on_severity" ]; then
  _fail_on_severity="$fail_on_severity"
fi
set_env "$WORK_ROOTFS" "SECURITY_MODE=$security_mode"
set_env "$WORK_ROOTFS" "FAIL_ON_SEVERITY=$_fail_on_severity"

# Prepare output rootfs
mkdir -p "$dest/rootfs"
rsync -aHAX --delete "$WORK_ROOTFS"/ "$dest/rootfs"/

# Define env vars to load the bash profile in non interactive shells
# Add cache environment variables so caching is straightforward
jq -n "{
  env: [$(sed 's/.*/\"&\"/' /tmp/env_vars | tr '\n' ',' | sed 's/,$//')],
  user: \"\"}
" > "$dest/metadata.json"

log_on_error cat "$dest/metadata.json"

if [ -n "$grype_config" ]; then
  echo "$grype_config" > ~/.grype.yaml
  cat ~/.grype.yaml
fi

if [ "$security_mode" = "strictest" ] || [ "$security_mode" = "strict" ] || [ "$security_mode" = "default" ]; then
  info "Scanning container rootfs for security vulnerabilities (fail on severity: $_fail_on_severity)"
  log_on_error grype db update
  log_on_error grype "dir:$dest/rootfs" --fail-on $_fail_on_severity
fi

info "Total size of setup-runtime rootfs: $(du -sh "$dest/rootfs" | awk '{print $1}')"

touch /tmp/metadata || true

METADATA=$(cat /tmp/metadata 2>/dev/null | tr -s '\n' ',' | sed 's/,$//')

jq -n \
  --arg hash "$hash" \
  "{ version: { hash: \$hash }, metadata: [$METADATA] }" >&3
